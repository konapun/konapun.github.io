{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/ideas-for-a-new-templating-language/","result":{"data":{"markdownRemark":{"id":"48fa2ec1-1e8f-52cb-93da-41f39bee03e6","excerpt":"ALL INFO IS BRAINSTORMING AND SUBJECT TO CHANGE Like many self-proclaimed techies, especially those with an affinity for Linux, I enjoy tinkering. Particularly…","html":"<p><strong>ALL INFO IS BRAINSTORMING AND SUBJECT TO CHANGE</strong></p>\n<p>Like many self-proclaimed techies, especially those with an affinity for Linux, I enjoy tinkering. Particularly, I like tinkering with my development config and modifying <a href=\"https://github.com/konapun/dotfiles\" target=\"_blank\" rel=\"noopener noreferrer\">my dotfiles</a>\nand in the process have wanted to make my configuration configurable as well (themability!).</p>\n<p>I’ve added a rudimentary sed-based templating system to make my dotfiles configurable and while it works,\nit just feels… messy somehow. The files themselves are no longer usable without running through my install\nscript as the template pieces aren’t valid syntax in any of the various files.</p>\n<h2>Requirements for a Solution</h2>\n<p>As I require the dotfile to be a standalone config file, the new templating system (henceforth referred to as <code class=\"language-text\">Cactus</code> for reasons which will be explained later) should consist of markup which\nis combined with the dotfile itself to generate a template.</p>\n<p>As a second requirement, I want to be able to develop this sytem somewhat quickly and only want to create a barebones DSL for markup and have the majority of the logic take place within the piece\nthat acts on the template which was generated by the informed config file (config data + markup). For this reason, Cactus should have a robust API for interacting with the compiled file.\nThis is CaCtus - <strong>Code as Configuration</strong>.</p>\n<p>Cactus config should act as a tree. There should be a root config file, containing things like language extensions, global variables, and files to process, and each file to process is recursively\nits own config file. The root config should live at <code class=\"language-text\">~/.config/cactus/cactus.json</code> (probably JSON since this will most likely use Node.js for reasons given in <strong>Other Bells and Whistles</strong> below).</p>\n<p>Cactus needs a cache. Since Cactus files are compiled into a template, this compilation should only occur as needed so the compiled version should be cached. Cache invalidation will either occur\nby checking the last modified date on the source file and compiled file and recompiling if necessary or by manual compilation as desired through use of the driver program.</p>\n<p>Cactus will have a driver program. This program will allow control over compilation and the daemon (ooh, spooky). More on daemon throughts below.</p>\n<h3>Bonus</h3>\n<p>An ambitous bonus would be an event simpler markup system using heuristics to generate a compiled Cactus file (e.g. using spacing and comments to determine blocks, etc). While less powerful than\nCactus markup, the host language API would be able to pick up the slack to achieve the same functionality. While this is probably technically feasible, it’s not without its downsides.</p>\n<ul>\n<li>\n<p>Pros:</p>\n<ul>\n<li>Cleaner config files</li>\n</ul>\n</li>\n<li>\n<p>Cons:</p>\n<ul>\n<li>Imperfect heuristics will require more frequent updates</li>\n<li>Configuration processing logic is moved from compile time to runtime</li>\n<li>Configuration processing lives spatially further from the configuration it acts on leading to a greater penchant for Cactus to get out of sync with its config file</li>\n</ul>\n</li>\n</ul>\n<h2>Rundown</h2>\n<p>After installing Cactus and adding the necessary config, the <code class=\"language-text\">cactus</code> binary will be used to compile a template from the config:</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">cactus compile # reads config in ~/.cactus/cactus.json and runs compilation based on config</code></pre></div>\n<p>If there were no compilation errors, template files will have been added to the Cactus cache. The <code class=\"language-text\">cactus</code> binary can now act on the templates to write a config. This step runs the Javascript files that\nuse the Cactus API to interact with the template files.</p>\n<p>In this example, the Javascript files specified a global variable called <code class=\"language-text\">theme</code>. The user has tied the value of this variable to a config object which specifies downstream configuration values for\nvarious programs which are themable.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">cactus set theme nord</code></pre></div>\n<p>Afer this step, the new dotfiles have been written. Note that running <code class=\"language-text\">cactus compile</code> at this point would compile the newly created dotfiles into a new template (though if this turns out to not be the\ndesired behavior we could cache SHAs of the template files to check whether they were modified by a user since being written).</p>\n<h2>Markdown Considerations</h2>\n<p>In order to avoid polluting the config file it lives in it should be placed within comments and use unambiguous start tags as to avoid having to deal with escape sequences. It should be simple but\npowerful; it needs to be able to instruct the compiler how to generate tokens from a config file of any syntax.</p>\n<p>But how do I know ahead of time how powerful this system needs to be? Well, I don’t know and because of that I need a simple yet powerful SYNTAX (for sure I’m thinking Scheme!). I should aim to make\navailable a good set of functions for use within the cactus template for interacting with the config file. For those things I don’t think of that others may need, I’ll create a Javascript extension\nAPI to allow others to use Javascript to export functions for use within Cactus templates.</p>\n<p>As stated earlier, a Javascript API will act on the compiled template. To inform the API of available actions on a Cactus node, Cactus nodes will be typed. I foresee there being at least three types\nand more likely four or more:</p>\n<ul>\n<li>\n<p>Variables</p>\n<ul>\n<li>Allow replacing a value</li>\n</ul>\n</li>\n<li>\n<p>Sections</p>\n<ul>\n<li>Allow portions of the configuration to be turned on/off (for instance, if you want to keep separate profiles for Mac and Linux in the same file and only enable one at a time)</li>\n</ul>\n</li>\n<li>\n<p>Switches</p>\n<ul>\n<li>Allow a single option to be selected from a list of many (for instance, if you had multiple Plug themes listed in your config file but only wanted one installed at a time you could list them all but comment all but one)</li>\n</ul>\n</li>\n</ul>\n<h3>Example</h3>\n<div class=\"gatsby-highlight\" data-language=\"vim\"><pre class=\"language-vim\"><code class=\"language-vim\"><span class=\"token comment\">\" @cactus variable colorscheme {(extract-from </span><span class=\"token string\">'nord'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">colorscheme</span> nord\n\n<span class=\"token comment\">\" @cactus section lisp begin</span>\nPlug <span class=\"token string\">'guns/vim-sexp'</span>\nPlug <span class=\"token string\">'tpope/vim-sexp-mappings-for-regular-people'</span>\nPlug <span class=\"token string\">'Olical/conjure'</span>\nPlug <span class=\"token string\">'clojure-vim/vim-jack-in'</span>\n<span class=\"token comment\">\" @cactus end</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> cactus <span class=\"token keyword\">from</span> <span class=\"token string\">'@cactus/core'</span>\n\n<span class=\"token keyword\">const</span> config <span class=\"token operator\">=</span> <span class=\"token function\">cactus</span><span class=\"token punctuation\">(</span><span class=\"token string\">'./init.vim'</span><span class=\"token punctuation\">)</span>\n\nconfig<span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span><span class=\"token string\">'colorscheme'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token string\">'gruvbox'</span><span class=\"token punctuation\">)</span>\n\nconfig<span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span><span class=\"token string\">'lisp'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">remove</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<h2>Supported Use Cases</h2>\n<h3>Keeping Static Config Files</h3>\n<p>If you keep a repo of your dotfiles, the most common use case is to maintain the static version of your config and use Cactus to modify portions of it, such as generating a theme.</p>\n<h3>Using Generated Files as Input Files</h3>\n<p>If you like to live on the edge, you may just have your single set of dotfiles not stored in a repo. If this is the case, you can still use Cactus. Rather than using static files from a repo as input,\nCactus can act on the dotfiles, compile a template, and then run Cactus actions on that template to replace the initial input file. If you decide to go this route be sure not to reference data which may\nbe altered by Cactus (such as extracting a value to a variable which may change based on dynamic configuration)!</p>\n<p><code class=\"language-text\">cactus compile</code></p>\n<h2>Proposed Configuration Structures</h2>\n<p>There are three main files involved in a Cactus configuration: a main Cactus config file, a config file with cactus templates, and a javascript file which acts on the template.</p>\n<p>I’ll consider two different structures for organizing a Cactus-federated configuration suite: Centralized and Distributed organization</p>\n<h3>Centralized</h3>\n<p>In a centralized configuration, Cactus-specific files reside in a single place (everything aside from Cactus templates which still go in the corresponding files they act on).</p>\n<h3>Distributed</h3>\n<p>In a distributed configuration, Cactus-specific files (i.e. the Node files which utilize the Cactus API) live alongside the config files for the various programs being configured.</p>\n<h2>Other Bells and Whistles</h2>\n<p>Since this may already be the most overengineered configuration solution ever conceived, let’s go one step further and add a “killer feature”.</p>\n<p>With other config systems you usually have a single point of control. If you want to change a theme, you need to go through the right place to apply that theme everywhere (e.g. changing your alacritty\ntheme will not also change your vim theme). What if updating any of your configs also applied changes elsewhere?</p>\n<p>Enter the Cactus Daemon. This will watch target files for changes and propogate related changes to other configurations in the Cactus federation. I haven’t thought through this much yet so additional\nideas will be forthcoming (or more likely, abandoned) as the project progresses.</p>","frontmatter":{"title":"Ideas For a New Templating Language","date":"November 12, 2020","description":"Designing a non-destructive templating system by use of an informed compiler"}},"allMarkdownRemark":{"edges":[{"node":{"excerpt":"ALL INFO IS BRAINSTORMING AND SUBJECT TO CHANGE Like many self-proclaimed techies, especially those with an affinity for Linux, I enjoy…","fields":{"slug":"/ideas-for-a-new-templating-language/"},"frontmatter":{"date":"November 12, 2020","title":"Ideas For a New Templating Language","description":"Designing a non-destructive templating system by use of an informed compiler"}}},{"node":{"excerpt":"Recently, someone asked on a programming subreddit if there was a way in a node\nExpress app to reduce duplicated error handling logic when…","fields":{"slug":"/using-proxy-objects/"},"frontmatter":{"date":"June 16, 2020","title":"Using Proxy Objects","description":"A problem and solution using a Proxy"}}},{"node":{"excerpt":"After years of on and off work, Orbital Frame has been released to npm as an alpha! For full details, check out the GitHub repo and try an…","fields":{"slug":"/introducing-orbital-frame/"},"frontmatter":{"date":"May 15, 2020","title":"Introducing Orbital Frame","description":"Unleash the power of UNIX in your chatbot!"}}},{"node":{"excerpt":"Figured I’d throw a quick site together to host project demos. This site is\npowered by Gatsby and is based on a modified mashup of\ngatsby…","fields":{"slug":"/hello-world/"},"frontmatter":{"date":"April 19, 2020","title":"Hello World","description":"A bit about this site"}}}]}},"pageContext":{"slug":"/ideas-for-a-new-templating-language/","previous":{"fields":{"slug":"/using-proxy-objects/"},"frontmatter":{"title":"Using Proxy Objects"}},"next":null}}}